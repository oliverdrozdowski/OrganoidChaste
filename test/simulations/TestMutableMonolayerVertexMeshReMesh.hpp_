/*

Copyright (c) 2005-2019, University of Oxford.
Copyright (c) 2025, Oliver M. Drozdowski and Ulrich S. Schwarz (Heidelberg University)

All rights reserved.

University of Oxford means the Chancellor, Masters and Scholars of the
University of Oxford, having an administrative office at Wellington
Square, Oxford OX1 2JD, UK.

This file is part of Chaste.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 * Neither the name of the University of Oxford nor the names of its
   contributors may be used to endorse or promote products derived from this
   software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#ifndef TESTMUTABLEMONOLAYERVERTEXMESHREMESH_HPP_
#define TESTMUTABLEMONOLAYERVERTEXMESHREMESH_HPP_

#include <cxxtest/TestSuite.h>

#include "MonolayerVertexMeshWriter.hpp"
#include "MutableMonolayerVertexMesh.hpp"
#include "FileComparison.hpp"
#include "Warnings.hpp"

//This test is always run sequentially (never in parallel)
#include "FakePetscSetup.hpp"

class TestMutableMonolayerVertexMeshReMesh : public CxxTest::TestSuite
{
public:

    void TestPerformNodeMerge()
    {
        /*
         * Create a mesh comprising a single triangular finite thickness element, as shown below.
         * We will test that the nodes marked with an x are merged correctly.
         *				 /|
				 *			  / |
         *      /|  |
         *     / |  |
         *    /  |  |
         *   /...|..|
         *  /: ::| / 
         *  --xx- /
         */
        std::vector<Node<3>*> nodes;
        nodes.push_back(new Node<3>(0, true, 0.0, 0.0, 0.0));
        nodes.push_back(new Node<3>(1, true, 1.0, 0.0, 0.0));
        nodes.push_back(new Node<3>(2, true, 1.0, 1.0, 0.0));
        nodes.push_back(new Node<3>(3, true, 0.4, 0.0, 0.0));
        nodes.push_back(new Node<3>(4, true, 0.6, 0.0, 0.0));
				
        nodes.push_back(new Node<3>(5, true, 0.0, 0.0, 1.0));
        nodes.push_back(new Node<3>(6, true, 1.0, 0.0, 1.0));
        nodes.push_back(new Node<3>(7, true, 1.0, 1.0, 1.0));
        nodes.push_back(new Node<3>(8, true, 0.4, 0.0, 1.0));
        nodes.push_back(new Node<3>(9, true, 0.6, 0.0, 1.0));
				
				std::vector<MonolayerVertexElementType> node_types;
				for(unsigned i=0; i<10; i++)
				{
					if(i<5)
					{
						node_types.push_back(MonolayerVertexElementType::Basal)
					}
					else
					{
						node_types.push_back(MonolayerVertexElementType::Apical)
					}
				}

				std::vector< unsigned[5]> node_indices_all_faces;
				node_indices_all_faces.push_back({0, 2, 1, 4, 5});
				node_indices_all_faces.push_back({5, 8, 9, 6, 7});
				node_indices_all_faces.push_back({0, 5, 7, 2, 100});
				node_indices_all_faces.push_back({2, 7, 6, 1, 100});
				node_indices_all_faces.push_back({1, 6, 9, 4, 100});
				node_indices_all_faces.push_back({4, 9, 8, 3, 100});
				node_indices_all_faces.push_back({3, 8, 5, 0, 100}); // 100 just placeholder
				
				MonolayerVertexElementType[7] face_types_all = {MonolayerVertexElementType::Basal,
																												MonolayerVertexElementType::Apical,
																												MonolayerVertexElementType::Lateral,
																												MonolayerVertexElementType::Lateral,
																												MonolayerVertexElementType::Lateral,
																												MonolayerVertexElementType::Lateral,
																												MonolayerVertexElementType::Lateral};

				std::vector<MonolayerVertexElement<2,3>*> face_elements;
				std::vector<bool> orientations;
        for (unsigned i=0; i<7; i++)
        {
            std::vector<Node<3>*> temp_nodes;
						std::vector<MonolayerVertexElementType> temp_types;
						unsigned max_index = i<2 ? 5 : 4;
						for(unsigned j=0; j<max_index; j++)
						{
							temp_nodes.push_back( nodes[node_indices_all_faces[i][j]] )
							temp_types.push_back( node_types[node_indices_all_faces[i][j]] )	
						}
						face_elements.push_back(new MonolayerVertexElement<2,3>(i, face_types_all[i], temp_nodes, temp_types));
						orientations.push_back(true);
        }

        std::vector<MonolayerVertexElement<3,3>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<3,3>(0, MonolayerVertexElementType::Undefined, face_elements, orientations, nodes, node_types));

        MutableMonlayerMesh<3,3> vertex_mesh(nodes, vertex_elements);

        // Merge nodes 3 and 4
				MonolayerVertexElement<2,3>* pFace = face_elements[5];
        vertex_mesh.IdentifySwapType(vertex_mesh.GetNode(3), vertex_mesh.GetNode(4), pFace);

        // Test the mesh is correctly updated
        TS_ASSERT_EQUALS(vertex_mesh.GetNumElements(), 1u);
        TS_ASSERT_EQUALS(vertex_mesh.GetNumNodes(), 8u);
				TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNumFaces(), 4u);

        // Test the correct nodes are boundary nodes
        for (unsigned i=0; i<8; i++)
        {
            TS_ASSERT_EQUALS(vertex_mesh.GetNode(i)->IsBoundaryNode(), true);
        }

        // Test the merged nodes are in the correct place
        TS_ASSERT_DELTA(vertex_mesh.GetNode(3)->rGetLocation()[0], 0.5, 1e-3);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(3)->rGetLocation()[1], 0.0, 1e-3);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(3)->rGetLocation()[2], 0.0, 1e-3);
				
        TS_ASSERT_DELTA(vertex_mesh.GetNode(7)->rGetLocation()[0], 0.5, 1e-3);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(7)->rGetLocation()[1], 0.0, 1e-3);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(7)->rGetLocation()[1], 1.0, 1e-3);

        // Test the elements own the correct nodes
        TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNumNodes(), 8u);
				pFace = vertex_mesh.GetElement(0)->GetFace(4);
				TS_ASSERT_EQUALS(oFace->GetNumNodes(), 4u);
        TS_ASSERT_EQUALS(pFace->GetNodeGlobalIndex(0), 2u);
				TS_ASSERT_EQUALS(pFace->GetNodeGlobalIndex(1), 6u);
				TS_ASSERT_EQUALS(pFace->GetNodeGlobalIndex(2), 7u);
				TS_ASSERT_EQUALS(pFace->GetNodeGlobalIndex(3), 3u);

        // Test the element's area and perimeter are computed correctly
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(0), 0.5, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(0), 3+sqrt(2.0), 1e-6);
    }

    void TestPerformNodeMergeWhenLowIndexNodeMustBeAddedToElement()
    {
        /**
         * Create a mesh comprising two square elements, as shown below. We will test that the
         * nodes marked with an x are merged correctly. We will test node merging in the case
         * where, when the elements previously containing the high-index node are updated to
         * contain the low-index node, at least one of these elements did not already contain
         * the low-index node.
         *
         *   -----x-x---
         *  |     |     |
         *  |     |     |
         *   ----- -----
         *
         * \todo I think this should be a T1 swap (see #1263)
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, true, 0.00, 0.00));
        nodes.push_back(new Node<2>(1, true, 1.00, 0.00));
        nodes.push_back(new Node<2>(2, true, 2.00, 0.00));
        nodes.push_back(new Node<2>(3, true, 2.00, 1.00));
        nodes.push_back(new Node<2>(4, true, 1.01, 1.00));
        nodes.push_back(new Node<2>(5, true, 1.00, 1.00));
        nodes.push_back(new Node<2>(6, true, 0.00, 2.00));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1;
        unsigned node_indices_elem_0[4] = {0, 1, 5, 6};
        unsigned node_indices_elem_1[5] = {1, 2, 3, 4, 5};
        for (unsigned i=0; i<5; i++)
        {
            if (i < 4)
            {
                nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
            }
            nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
        }

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);

        // Merge nodes 4 and 5
        vertex_mesh.IdentifySwapType(vertex_mesh.GetNode(4), vertex_mesh.GetNode(5));

        // Test the mesh is correctly updated
        TS_ASSERT_EQUALS(vertex_mesh.GetNumElements(), 2u);
        TS_ASSERT_EQUALS(vertex_mesh.GetNumNodes(), 6u);

        // Test the correct nodes are boundary nodes
        for (unsigned i=0; i<vertex_mesh.GetNumNodes(); i++)
        {
            TS_ASSERT_EQUALS(vertex_mesh.GetNode(i)->IsBoundaryNode(), true);
        }

        // Test that the moved node has the correct location following the rearrangement
        TS_ASSERT_DELTA(vertex_mesh.GetNode(4)->rGetLocation()[0], 1.005, 1e-8);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(4)->rGetLocation()[1], 1.0, 1e-8);

        // Test the elements own the correct nodes
        TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNumNodes(), 4u);
        TS_ASSERT_EQUALS(vertex_mesh.GetElement(1)->GetNumNodes(), 4u);
        unsigned node_indices_element_0[4] = {0, 1, 4, 5};
        unsigned node_indices_element_1[4] = {1, 2, 3, 4};
        for (unsigned i=0; i<4; i++)
        {
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNodeGlobalIndex(i), node_indices_element_0[i]);
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(1)->GetNodeGlobalIndex(i), node_indices_element_1[i]);
        }
    }

		// This is next
    void TestPerformT1SwapAndIdentifySwapType()
    {
        /*
         * Create a mesh comprising six nodes contained in two triangle and two rhomboid elements, as shown below.
         * We will test that that a T1 swap of the two central nodes is correctly implemented.
         *  _____
         * |\   /|
         * | \ / |
         * |  |  |
         * | / \ |
         * |/___\|
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, true,  0.0, 0.0));
        nodes.push_back(new Node<2>(1, true,  1.0, 0.0));
        nodes.push_back(new Node<2>(2, true,  1.0, 1.0));
        nodes.push_back(new Node<2>(3, true,  0.0, 1.0));
        nodes.push_back(new Node<2>(4, false, 0.5, 0.4));
        nodes.push_back(new Node<2>(5, false, 0.5, 0.6));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1, nodes_elem_2, nodes_elem_3;
        unsigned node_indices_elem_0[3] = {2, 3, 5};
        unsigned node_indices_elem_1[4] = {2, 5, 4, 1};
        unsigned node_indices_elem_2[3] = {1, 4, 0};
        unsigned node_indices_elem_3[4] = {0, 4, 5, 3};
        for (unsigned i=0; i<4; i++)
        {
            if (i < 3)
            {
                nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
                nodes_elem_2.push_back(nodes[node_indices_elem_2[i]]);
            }
            nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
            nodes_elem_3.push_back(nodes[node_indices_elem_3[i]]);
        }

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(2, nodes_elem_2));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(3, nodes_elem_3));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);

        // Set the threshold distance between vertices for a T1 swap as follows, to ease calculations
        vertex_mesh.SetCellRearrangementThreshold(0.1*2.0/1.5);

        // Perform a T1 swap on nodes 4 and 5
        vertex_mesh.IdentifySwapType(vertex_mesh.GetNode(4), vertex_mesh.GetNode(5));

        // Test that each moved node has the correct location following the rearrangement
        TS_ASSERT_DELTA(vertex_mesh.GetNode(4)->rGetLocation()[0], 0.6, 1e-8);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(4)->rGetLocation()[1], 0.5, 1e-8);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(5)->rGetLocation()[0], 0.4, 1e-3);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(5)->rGetLocation()[1], 0.5, 1e-3);

        // Test that each element contains the correct nodes following the rearrangement
        unsigned node_indices_element_0[4] = {2, 3, 5, 4};
        unsigned node_indices_element_1[3] = {2, 4, 1};
        unsigned node_indices_element_2[4] = {1, 4, 5, 0};
        unsigned node_indices_element_3[3] = {0, 5, 3};
        for (unsigned i=0; i<4; i++)
        {
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNodeGlobalIndex(i), node_indices_element_0[i]);
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(2)->GetNodeGlobalIndex(i), node_indices_element_2[i]);
            if (i < 3)
            {
                TS_ASSERT_EQUALS(vertex_mesh.GetElement(1)->GetNodeGlobalIndex(i), node_indices_element_1[i]);
                TS_ASSERT_EQUALS(vertex_mesh.GetElement(3)->GetNodeGlobalIndex(i), node_indices_element_3[i]);
            }
        }

        // Test that each element has the correct area and perimeter following the rearrangement
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(0), 0.3, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(1), 0.2,1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(2), 0.3, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(3), 0.2, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(0), 1.2+0.2*sqrt(41.0), 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(1), 1.0+0.2*sqrt(41.0), 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(2), 1.2+0.2*sqrt(41.0), 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(3), 1.0+0.2*sqrt(41.0), 1e-6);

        // Test T1 swap location tracking
        std::vector< c_vector<double, 2> > t1_locations = vertex_mesh.GetLocationsOfT1Swaps();
        TS_ASSERT_EQUALS(t1_locations.size(), 1u);
        TS_ASSERT_DELTA(t1_locations[0][0], 0.5, 1e-6);
        TS_ASSERT_DELTA(t1_locations[0][1], 0.5, 1e-6);

        // Test T1 swap location clearing
        vertex_mesh.ClearLocationsOfT1Swaps();
        t1_locations = vertex_mesh.GetLocationsOfT1Swaps();
        TS_ASSERT_EQUALS(t1_locations.size(), 0u);
    }

    void TestPerformT1SwapOnBoundary()
    {
        /*
         * Create a mesh comprising six nodes contained in three elements such that all nodes are
         * boundary nodes, as shown below. We will test that that a T1 swap is correctly implemented.
         *  _____
         * |\   /
         * | \ /
         * |  |
         * | / \
         * |/___\
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, true, 0.0, 0.0));
        nodes.push_back(new Node<2>(1, true, 1.0, 0.0));
        nodes.push_back(new Node<2>(2, true, 1.0, 1.0));
        nodes.push_back(new Node<2>(3, true, 0.0, 1.0));
        nodes.push_back(new Node<2>(4, true, 0.5, 0.4));
        nodes.push_back(new Node<2>(5, true, 0.5, 0.6));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1, nodes_elem_2;
        unsigned node_indices_elem_0[3] = {2, 3, 5};
        unsigned node_indices_elem_1[3] = {1, 4, 0};
        unsigned node_indices_elem_2[4] = {0, 4, 5, 3};
        for (unsigned i=0; i<4; i++)
        {
            if (i < 3)
            {
                nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
                nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
            }
            nodes_elem_2.push_back(nodes[node_indices_elem_2[i]]);
        }

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(2, nodes_elem_2));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);

        // Set the threshold distance between vertices for a T1 swap as follows, to ease calculations
        vertex_mesh.SetCellRearrangementThreshold(0.1*2.0/1.5);

        // Perform a T1 swap on nodes 5 and 4 (this way round to ensure coverage of boundary node tracking)
        vertex_mesh.IdentifySwapType(vertex_mesh.GetNode(5), vertex_mesh.GetNode(4));

        // Test that each moved node has the correct location following the rearrangement
        TS_ASSERT_DELTA(vertex_mesh.GetNode(4)->rGetLocation()[0], 0.6, 1e-8);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(4)->rGetLocation()[1], 0.5, 1e-8);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(5)->rGetLocation()[0], 0.4, 1e-3);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(5)->rGetLocation()[1], 0.5, 1e-3);

        // Test that each element contains the correct number nodes following the rearrangement
        TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNumNodes(), 4u);
        TS_ASSERT_EQUALS(vertex_mesh.GetElement(1)->GetNumNodes(), 4u);
        TS_ASSERT_EQUALS(vertex_mesh.GetElement(2)->GetNumNodes(), 3u);

        // Test that each element contains the correct nodes following the rearrangement
        unsigned node_indices_element_0[4] = {2, 3, 5, 4};
        unsigned node_indices_element_1[4] = {1, 4, 5, 0};
        unsigned node_indices_element_2[4] = {0, 5, 3};
        for (unsigned i=0; i<4; i++)
        {
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNodeGlobalIndex(i), node_indices_element_0[i]);
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(1)->GetNodeGlobalIndex(i), node_indices_element_1[i]);
            if (i < 3)
            {
                TS_ASSERT_EQUALS(vertex_mesh.GetElement(2)->GetNodeGlobalIndex(i), node_indices_element_2[i]);
            }
        }

        // Test that each element has the correct area and perimeter following the rearrangement
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(0), 0.3, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(1), 0.3, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(2), 0.2, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(0), 1.2+0.2*sqrt(41.0), 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(1), 1.2+0.2*sqrt(41.0), 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(2), 1.0+0.2*sqrt(41.0), 1e-6);

        // Test that the correct nodes are labelled as boundary nodes following the rearrangement
        for (unsigned i=0; i<vertex_mesh.GetNumNodes(); i++)
        {
            bool expected_boundary_node = (i!=5);
            TS_ASSERT_EQUALS(vertex_mesh.GetNode(i)->IsBoundaryNode(), expected_boundary_node);
        }
    }

    void TestPerformT1SwapOnBoundary2()
    {
        /*
         * Create a mesh comprising six nodes contained in three elements such that all but one node
         * are boundary nodes, as shown below. We will test that that a T1 swap is correctly implemented.
         *
         * |\   /|
         * | \ / |
         * |  |  |
         * | / \ |
         * |/___\|
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, true,  0.0, 0.0));
        nodes.push_back(new Node<2>(1, true,  1.0, 0.0));
        nodes.push_back(new Node<2>(2, true,  1.0, 1.0));
        nodes.push_back(new Node<2>(3, true,  0.0, 1.0));
        nodes.push_back(new Node<2>(4, false, 0.5, 0.4));
        nodes.push_back(new Node<2>(5, true,  0.5, 0.6));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1, nodes_elem_2;
        unsigned node_indices_elem_0[4] = {1, 2, 5, 4};
        unsigned node_indices_elem_1[3] = {1, 4, 0};
        unsigned node_indices_elem_2[4] = {0, 4, 5, 3};
        for (unsigned i=0; i<4; i++)
        {
            nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
            if (i < 3)
            {
                nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
            }
            nodes_elem_2.push_back(nodes[node_indices_elem_2[i]]);
        }

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(2, nodes_elem_2));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);

        // Set the threshold distance between vertices for a T1 swap as follows, to ease calculations
        vertex_mesh.SetCellRearrangementThreshold(0.1*2.0/1.5);

        TS_ASSERT_EQUALS(vertex_mesh.GetNumElements(), 3u);
        TS_ASSERT_EQUALS(vertex_mesh.GetNumNodes(), 6u);

        // Perform a T1 swap on nodes 5 and 4 (this way round to ensure coverage of boundary node tracking)
        vertex_mesh.IdentifySwapType(vertex_mesh.GetNode(5), vertex_mesh.GetNode(4));

        // Test that each moved node has the correct location following the rearrangement
        TS_ASSERT_DELTA(vertex_mesh.GetNode(4)->rGetLocation()[0], 0.6, 1e-8);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(4)->rGetLocation()[1], 0.5, 1e-8);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(5)->rGetLocation()[0], 0.4, 1e-3);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(5)->rGetLocation()[1], 0.5, 1e-3);

        // Test that each element contains the correct number nodes following the rearrangement
        TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNumNodes(), 3u);
        TS_ASSERT_EQUALS(vertex_mesh.GetElement(1)->GetNumNodes(), 4u);
        TS_ASSERT_EQUALS(vertex_mesh.GetElement(2)->GetNumNodes(), 3u);

        // Test that each element contains the correct nodes following the rearrangement
        unsigned node_indices_element_0[3] = {1, 2, 4};
        unsigned node_indices_element_1[4] = {1, 4, 5, 0};
        unsigned node_indices_element_2[3] = {0, 5, 3};
        for (unsigned i=0; i<4; i++)
        {
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(1)->GetNodeGlobalIndex(i), node_indices_element_1[i]);
            if (i < 3)
            {
                TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNodeGlobalIndex(i), node_indices_element_0[i]);
                TS_ASSERT_EQUALS(vertex_mesh.GetElement(2)->GetNodeGlobalIndex(i), node_indices_element_2[i]);
            }
        }

        // Test that each element has the correct area and perimeter following the rearrangement
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(0), 0.2, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(1), 0.3, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(2), 0.2, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(0), 1.0+0.2*sqrt(41.0), 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(1), 1.2+0.2*sqrt(41.0), 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(2), 1.0+0.2*sqrt(41.0), 1e-6);

        // Test that the correct nodes are labelled as boundary nodes following the rearrangement
        for (unsigned i=0; i<vertex_mesh.GetNumNodes(); i++)
        {
            TS_ASSERT_EQUALS(vertex_mesh.GetNode(i)->IsBoundaryNode(), true);
        }
    }

    void TestPerformT1SwapWhenVoidForms()
    {
        /*
         * Create a mesh containing six nodes containing in two elements. We will test that
         * a T1 swap is correctly performed in the case where a void forms as a result of
         * the rearrangement, as shown below.
         *
         * |\   /|     |\      /|
         * | \ / |     | \    / |
         * |  |  |  => | /    \ |
         * | / \ |     |/      \|
         * |/   \|
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, true, 0.0, 0.0));
        nodes.push_back(new Node<2>(1, true, 1.0, 0.0));
        nodes.push_back(new Node<2>(2, true, 1.0, 1.0));
        nodes.push_back(new Node<2>(3, true, 0.0, 1.0));
        nodes.push_back(new Node<2>(4, true, 0.5, 0.4));
        nodes.push_back(new Node<2>(5, true, 0.5, 0.6));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1;
        unsigned node_indices_elem_0[4] = {0, 4, 5, 3};
        unsigned node_indices_elem_1[4] = {4, 1, 2, 5};
        for (unsigned i=0; i<4; i++)
        {
            nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
            nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
        }

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);

        // Set the threshold distance between vertices for a T1 swap as follows, to ease calculations
        vertex_mesh.SetCellRearrangementThreshold(0.1*2.0/1.5);

        // Perform a T1 swap on nodes 5 and 4.
        vertex_mesh.IdentifySwapType(vertex_mesh.GetNode(5), vertex_mesh.GetNode(4));

        // Test that each moved node has the correct location following the rearrangement
        TS_ASSERT_DELTA(vertex_mesh.GetNode(4)->rGetLocation()[0], 0.6, 1e-8);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(4)->rGetLocation()[1], 0.5, 1e-8);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(5)->rGetLocation()[0], 0.4, 1e-3);
        TS_ASSERT_DELTA(vertex_mesh.GetNode(5)->rGetLocation()[1], 0.5, 1e-3);

        // Test that each element contains the correct number of nodes following the rearrangement
        TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNumNodes(), 3u);
        TS_ASSERT_EQUALS(vertex_mesh.GetElement(1)->GetNumNodes(), 3u);

        // Test that each element contains the correct nodes following the rearrangement
        unsigned node_indices_element_0[3] = {0, 5, 3};
        unsigned node_indices_element_1[3] = {4, 1, 2};
        for (unsigned i=0; i<3; i++)
        {
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNodeGlobalIndex(i), node_indices_element_0[i]);
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(1)->GetNodeGlobalIndex(i), node_indices_element_1[i]);
        }

        // Test that each element has the correct area and perimeter following the rearrangement
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(0), 0.2, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetVolumeOfElement(1), 0.2, 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(0), 1.0+0.2*sqrt(41.0), 1e-6);
        TS_ASSERT_DELTA(vertex_mesh.GetSurfaceAreaOfElement(1), 1.0+0.2*sqrt(41.0), 1e-6);

        // Test that the correct nodes are labelled as boundary nodes following the rearrangement
        for (unsigned i=0; i<vertex_mesh.GetNumNodes(); i++)
        {
            TS_ASSERT_EQUALS(vertex_mesh.GetNode(i)->IsBoundaryNode(), true);
        }
    }

    void TestPerformT1SwapExceptions()
    {
        /*
         * Create a mesh comprising six nodes containing in two triangle and two rhomboid elements,
         * where two nodes (those with indices 4 and 5) have the same location. We will test that
         * trying to perform a T1 swap on these nodes throws the correct exception.
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, false, 0.0, 0.0));
        nodes.push_back(new Node<2>(1, false, 1.0, 0.0));
        nodes.push_back(new Node<2>(2, false, 1.0, 1.0));
        nodes.push_back(new Node<2>(3, false, 0.0, 1.0));
        nodes.push_back(new Node<2>(4, false, 0.5, 0.5));
        nodes.push_back(new Node<2>(5, false, 0.5, 0.5));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1, nodes_elem_2, nodes_elem_3;
        unsigned node_indices_elem_0[3] = {2, 3, 5};
        unsigned node_indices_elem_1[4] = {2, 5, 4, 1};
        unsigned node_indices_elem_2[3] = {1, 4, 0};
        unsigned node_indices_elem_3[4] = {0, 4, 5, 3};
        for (unsigned i=0; i<4; i++)
        {
            if (i < 3)
            {
                nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
                nodes_elem_2.push_back(nodes[node_indices_elem_2[i]]);
            }
            nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
            nodes_elem_3.push_back(nodes[node_indices_elem_3[i]]);
        }

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(2, nodes_elem_2));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(3, nodes_elem_3));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);

        // Set the threshold distance between vertices for a T1 swap as follows, to ease calculations
        vertex_mesh.SetCellRearrangementThreshold(0.1*2.0/1.5);

        // Test that trying to perform a T1 swap on nodes 4 and 5 throws the correct exception
        TS_ASSERT_THROWS_THIS(vertex_mesh.IdentifySwapType(vertex_mesh.GetNode(4), vertex_mesh.GetNode(5)), "Nodes are too close together, this shouldn't happen");
    }

    void TestPerformT1SwapWithAddingEdgeToTriangularElement()
    {
        /**
         * Create a mesh comprising six nodes contained in two triangle and two rhomboid elements, as shown below.
         * We will test that the triangles are allowed to gain an edge.
         *  _____
         * |\   /|
         * | \ / |
         * |  |  |
         * | / \ |
         * |/___\|
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, true,  0.0, 0.0));
        nodes.push_back(new Node<2>(1, true,  1.0, 0.0));
        nodes.push_back(new Node<2>(2, true,  1.0, 1.0));
        nodes.push_back(new Node<2>(3, true,  0.0, 1.0));
        nodes.push_back(new Node<2>(4, false, 0.5, 0.4));
        nodes.push_back(new Node<2>(5, false, 0.5, 0.6));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1, nodes_elem_2, nodes_elem_3;
        unsigned node_indices_elem_0[3] = {2, 3, 5};
        unsigned node_indices_elem_1[4] = {2, 5, 4, 1};
        unsigned node_indices_elem_2[3] = {1, 4, 0};
        unsigned node_indices_elem_3[4] = {0, 4, 5, 3};
        for (unsigned i=0; i<4; i++)
        {
            if (i < 3)
            {
                nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
                nodes_elem_2.push_back(nodes[node_indices_elem_2[i]]);
            }
            nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
            nodes_elem_3.push_back(nodes[node_indices_elem_3[i]]);
        }

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(2, nodes_elem_2));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(3, nodes_elem_3));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);

        // Ensure that the inner node will swap
        vertex_mesh.SetCellRearrangementThreshold(0.21);

        // Perform a T1 swap on nodes 4 and 5
        vertex_mesh.CheckForSwapsFromShortEdges();

        // Test that each element contains the correct nodes following the rearrangement
        unsigned node_indices_element_0[4] = {2, 3, 5, 4};
        unsigned node_indices_element_1[3] = {2, 4, 1};
        unsigned node_indices_element_2[4] = {1, 4, 5, 0};
        unsigned node_indices_element_3[3] = {0, 5, 3};

        for (unsigned i=0; i<4; i++)
        {
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNodeGlobalIndex(i), node_indices_element_0[i]);
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(2)->GetNodeGlobalIndex(i), node_indices_element_2[i]);
            if (i < 3)
            {
                TS_ASSERT_EQUALS(vertex_mesh.GetElement(1)->GetNodeGlobalIndex(i), node_indices_element_1[i]);
                TS_ASSERT_EQUALS(vertex_mesh.GetElement(3)->GetNodeGlobalIndex(i), node_indices_element_3[i]);
            }
        }
    }

    void TestDoNotPerforT1SwapWithRemovingEdgeFromTriangularElement()
    {
        /**
         * In this test we check that a T1 swap does not occur if one of the elements is triangular
         * and would loose an edge by swapping nodes. The mesh looks like this
         *
         *       ______________
         *      |\             |
         *      | \ _________  |
         *      |  |          \| ...where the funny shaped element in the middle is supposed to be
         *      |  |_________ /|    a very long triangle that has the third vertex on the right hand boundary.
         *      | /            |
         *      |/_____________|
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, true,  0.0, 0.0));
        nodes.push_back(new Node<2>(1, true,  2.0, 0.0));
        nodes.push_back(new Node<2>(2, true,  2.0, 2.0));
        nodes.push_back(new Node<2>(3, true,  0.0, 2.0));
        nodes.push_back(new Node<2>(4, false, 0.2, 0.95));
        nodes.push_back(new Node<2>(5, true, 2.0, 1.0));
        nodes.push_back(new Node<2>(6, false, 0.2, 1.05));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1, nodes_elem_2, nodes_elem_3;
        unsigned node_indices_elem_0[4] = {0, 1, 5, 4};
        unsigned node_indices_elem_1[4] = {5, 2, 3, 6};
        unsigned node_indices_elem_2[4] = {0, 4, 6, 3};
        unsigned node_indices_elem_3[3] = { 4, 5, 6};
        for (unsigned i=0; i<4; i++)
        {
            if (i < 3)
            {
                nodes_elem_3.push_back(nodes[node_indices_elem_3[i]]);
            }
            nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
            nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
            nodes_elem_2.push_back(nodes[node_indices_elem_2[i]]);
        }

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(2, nodes_elem_2));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(3, nodes_elem_3));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);

        // Ensure that the inner edge will be considered for a swap
        vertex_mesh.SetCellRearrangementThreshold(0.11);

        // Check for T1 swaps and carry them out if allowed - the short edge should not swap!
        vertex_mesh.CheckForSwapsFromShortEdges();

        TS_ASSERT_EQUALS(vertex_mesh.GetElement(3)->GetNumNodes(), 3u);

        // Test that each element still contains the correct nodes following the rearrangement
        for (unsigned i=0; i<4; i++)
        {
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(0)->GetNodeGlobalIndex(i), node_indices_elem_0[i]);
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(1)->GetNodeGlobalIndex(i), node_indices_elem_1[i]);
            TS_ASSERT_EQUALS(vertex_mesh.GetElement(2)->GetNodeGlobalIndex(i), node_indices_elem_2[i]);
            if (i < 3)
            {
                TS_ASSERT_EQUALS(vertex_mesh.GetElement(3)->GetNodeGlobalIndex(i), node_indices_elem_3[i]);
            }
        }
    }

    void TestReMeshForT1Swaps()
    {
        /*
         * Read in a vertex mesh that contains several pairs of nodes that are close enough for
         * T1 swaps to be performed, as shown below. The mesh consists of six elements and all
         * T1 swaps are performed on all horizontal edges. We will test that the ReMesh() method
         * correctly performs T1 swaps for internal and boundary elements, and correctly updates
         * which nodes are labelled as boundary nodes.
         *
         *      /\    /\
         *     /  \__/  \
         *    /   /  \   \
         *    \__/\__/\__/
         *    /  \/  \/  \
         *    \   \__/   /
         *     \  /  \  /
         *      \/    \/
         */
        VertexMeshReader<2,2> mesh_reader("cell_based/test/data/TestMutableMonlayerMesh/vertex_remesh_T1");
        MutableMonlayerMesh<2,2> vertex_mesh;

        vertex_mesh.ConstructFromMeshReader(mesh_reader);
        vertex_mesh.SetCellRearrangementThreshold(0.1);

        TS_ASSERT_EQUALS(vertex_mesh.GetNumElements(), 8u);
        TS_ASSERT_EQUALS(vertex_mesh.GetNumNodes(), 22u);

        // Calls ReMesh() to identify and perform any T1 swaps
        vertex_mesh.ReMesh();

        TS_ASSERT_EQUALS(vertex_mesh.GetNumElements(), 8u);
        TS_ASSERT_EQUALS(vertex_mesh.GetNumNodes(), 22u);

        std::string dirname = "TestVertexMeshReMesh";
        std::string mesh_filename = "vertex_remesh_T1";

        // Save the mesh data using mesh writers
        VertexMeshWriter<2,2> mesh_writer(dirname, mesh_filename, false);
        mesh_writer.WriteFilesUsingMesh(vertex_mesh);

        // Check the positions are updated correctly
        OutputFileHandler handler("TestVertexMeshReMesh", false);
        std::string results_file1 = handler.GetOutputDirectoryFullPath() + "vertex_remesh_T1.node";
        std::string results_file2 = handler.GetOutputDirectoryFullPath() + "vertex_remesh_T1.cell";

        FileComparison comparer1(results_file1, "cell_based/test/data/TestMutableMonlayerMesh/vertex_remesh_T1_after_remesh.node");
        TS_ASSERT(comparer1.CompareFiles());
        FileComparison comparer2(results_file2, "cell_based/test/data/TestMutableMonlayerMesh/vertex_remesh_T1_after_remesh.cell");
        TS_ASSERT(comparer2.CompareFiles());
    }

    void TestReMeshExceptionWhenNonBoundaryNodesAreContainedOnlyInTwoElements()
    {
        /*
         * Create a mesh comprising six nodes contained in two elements, as shown below. We will test
         * that when we attempt to mesh the nodes marked x, the correct exception is thrown.
         *   ______
         *  |     /|
         *  |    / |
         *  |   x  |
         *  |  x   |
         *  | /    |
         *  |/_____|
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, true,  0.00, 0.00));
        nodes.push_back(new Node<2>(1, true,  1.00, 0.00));
        nodes.push_back(new Node<2>(2, true,  1.00, 1.00));
        nodes.push_back(new Node<2>(3, true,  0.00, 1.00));
        nodes.push_back(new Node<2>(4, false, 0.49, 0.49));
        nodes.push_back(new Node<2>(5, false, 0.51, 0.51));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1;
        unsigned node_indices_elem_0[5] = {0, 1, 2, 5, 4};
        unsigned node_indices_elem_1[5] = {0, 4, 5, 2, 3};
        for (unsigned i=0; i<5; i++)
        {
            nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
            nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
        }

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);
        vertex_mesh.SetCellRearrangementThreshold(0.1);

        TS_ASSERT_THROWS_THIS(vertex_mesh.ReMesh(), "There are non-boundary nodes contained only in two elements; something has gone wrong.");
    }

    void TestIdentifySwapTypeExceptionWhenBoundaryNodeIsContainedInThreeElements()
    {
        /*
         * Create a mesh as shown below, where the two nodes marked with an x are to be merged.
         * We will test that the correct exception is thrown when IdentifySwapType() is called.
         *             _____
         *           /      |
         *          /       |
         *   -----xx--------|
         *  |       \       |
         *  |________\______|
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, true, 0.00, 0.0));
        nodes.push_back(new Node<2>(1, true, 2.00, 0.0));
        nodes.push_back(new Node<2>(2, true, 3.00, 0.0));
        nodes.push_back(new Node<2>(3, true, 3.00, 1.0));
        nodes.push_back(new Node<2>(4, true, 3.00, 2.0));
        nodes.push_back(new Node<2>(5, true, 2.00, 2.0));
        nodes.push_back(new Node<2>(6, true, 1.00, 1.0));
        nodes.push_back(new Node<2>(7, true, 0.99, 1.0));
        nodes.push_back(new Node<2>(8, true, 0.00, 1.0));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1, nodes_elem_2;
        unsigned node_indices_elem_0[5] = {0, 1, 6, 7, 8};
        unsigned node_indices_elem_1[4] = {1, 2, 3, 6};
        unsigned node_indices_elem_2[4] = {3, 4, 5, 6};
        for (unsigned i=0; i<4; i++)
        {
            nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
            nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
            nodes_elem_2.push_back(nodes[node_indices_elem_2[i]]);
        }
        nodes_elem_0.push_back(nodes[node_indices_elem_0[4]]);

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(2, nodes_elem_2));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);
        vertex_mesh.SetCellRearrangementThreshold(0.1);

        TS_ASSERT_EQUALS(vertex_mesh.GetNumElements(), 3u);
        TS_ASSERT_EQUALS(vertex_mesh.GetNumNodes(), 9u);

        TS_ASSERT_THROWS_THIS(vertex_mesh.IdentifySwapType(vertex_mesh.GetNode(6), vertex_mesh.GetNode(7)), "There is a boundary node contained in three elements something has gone wrong.");
    }

    void TestReMeshExceptionWhenNonBoundaryNodeIsContainedOnlyInTwoElements()
    {
        /*
         * Create a mesh as shown below, where the two nodes marked with an x are to be merged.
         * We will test that the correct exception is thrown when ReMesh() is called.
         *
         * |\   /|
         * | \ / |
         * |  x  |
         * |  x  |
         * |__|__|
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, true, 0.0, 0.0));
        nodes.push_back(new Node<2>(1, true, 1.0, 0.0));
        nodes.push_back(new Node<2>(2, true, 1.0, 1.0));
        nodes.push_back(new Node<2>(3, true, 0.0, 1.0));
        nodes.push_back(new Node<2>(4, false, 0.5, 0.49));
        nodes.push_back(new Node<2>(5, true, 0.5, 0.51));
        nodes.push_back(new Node<2>(6, true, 0.5, 0.0));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1;
        unsigned node_indices_elem_0[5] = {1, 2, 5, 4, 6};
        unsigned node_indices_elem_1[5] = {0, 6, 4, 5, 3};
        for (unsigned i=0; i<5; i++)
        {
            nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
            nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
        }

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);
        vertex_mesh.SetCellRearrangementThreshold(0.1);

        TS_ASSERT_THROWS_THIS(vertex_mesh.ReMesh(), "There is a non-boundary node contained only in two elements; something has gone wrong.");
    }

    void TestAnotherReMeshExceptionWhenNonBoundaryNodesAreContainedOnlyInTwoElements()
    {
        /*
         * Create a mesh as shown below, where the two central nodes marked with an x are to be merged. We will
         * test that the correct exception is thrown when ReMesh() is called. Note that the extra node at the
         * top of the mesh is required to stop the element from containing only three nodes, otherwise the
         * ReMesh() method would not call IdentifySwapType().
         *
         *  __x__
         * |\   /|
         * | \ / |
         * |  x  |
         * |  x  |
         * |__|__|
         */
        std::vector<Node<2>*> nodes;
        nodes.push_back(new Node<2>(0, true,  0.0, 0.00));
        nodes.push_back(new Node<2>(1, true,  1.0, 0.00));
        nodes.push_back(new Node<2>(2, true,  1.0, 1.00));
        nodes.push_back(new Node<2>(3, true,  0.0, 1.00));
        nodes.push_back(new Node<2>(4, false, 0.5, 0.49));
        nodes.push_back(new Node<2>(5, false, 0.5, 0.51));
        nodes.push_back(new Node<2>(6, true,  0.5, 0.00));
        nodes.push_back(new Node<2>(7, true,  0.5, 1.00));

        std::vector<Node<2>*> nodes_elem_0, nodes_elem_1, nodes_elem_2;
        unsigned node_indices_elem_0[5] = {1, 2, 5, 4, 6};
        unsigned node_indices_elem_1[5] = {0, 6, 4, 5, 3};
        unsigned node_indices_elem_2[4] = {2, 3, 5, 7};
        for (unsigned i=0; i<4; i++)
        {
            nodes_elem_0.push_back(nodes[node_indices_elem_0[i]]);
            nodes_elem_1.push_back(nodes[node_indices_elem_1[i]]);
            nodes_elem_2.push_back(nodes[node_indices_elem_2[i]]);
        }
        nodes_elem_0.push_back(nodes[node_indices_elem_0[4]]);
        nodes_elem_1.push_back(nodes[node_indices_elem_1[4]]);

        std::vector<MonolayerVertexElement<2,2>*> vertex_elements;
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(0, nodes_elem_0));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(1, nodes_elem_1));
        vertex_elements.push_back(new MonolayerVertexElement<2,2>(2, nodes_elem_2));

        MutableMonlayerMesh<2,2> vertex_mesh(nodes, vertex_elements);
        vertex_mesh.SetCellRearrangementThreshold(0.1);

        TS_ASSERT_THROWS_THIS(vertex_mesh.ReMesh(), "There are non-boundary nodes contained only in two elements; something has gone wrong.");
    }

};

#endif /*TESTMUTABLEMONOLAYERVERTEXMESHREMESH_HPP_*/
